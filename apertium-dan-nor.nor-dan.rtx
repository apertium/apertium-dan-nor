! nor-dan.rtx

!!!!!!!!!!!!!!!!!!!!!!!!!
! Attribute Categories: !
!!!!!!!!!!!!!!!!!!!!!!!!!

gender = m f nt ut un fn mf xpst xpsts xpsto xcomp xsup acr GD ;
gender_n = m f nt ut un fn mf acr GD ;
! TODO do I need non_overwritable_gender = … @mf ;
gender_adj_sg_ind = nt ut ;
number = sg pl sp ND ;
number_n = sg pl sp ND ;
defnes = def ind ;
tense = inf pret pres pp supn imp ;
person = (PD p3) p1 p2 p3 PD ;
voice = pasv actv ;
case = nom acc gen ;
! a_ for attribute:
a_adj = sint ord pp pprs ;
a_cmp = cmp cmp-split ;
a_det = dem rel qnt pos emph ;
a_neg = neg ;
a_comp = pst comp sup ;
a_clb = clb ;
mainpos = prn det adv adj n np cnjcoo cnjsub pr ij vbmod vbhaver vblex vbser vaux ;

! Word sets:
w_paux = bli blive være vere ;
w_bli = bli blive ;
w_supnaux = ha være vere ;

! We never turn pp's of these into pasv (regardless of temps):
w_no_pasv = aldres dages drages enes erfares fattes findes forefindes forældes færdes føles kappes kives ledes mindes mistrives mødes nedarves omgås opleves plages rygtes samles skilles skyldes slås snakkes stortrives trives træffes trænges tækkes undres vantrives væmmes være ynges ynkes ældes ;

! We never turn pp's of these into past.pasv:
w_no_past_pasv = afhjælpe afhænge afvige aldres angribe begribe behænge bestikke bide bifalde blankslide bundfryse bære dages domfælde drages drikke dybfryse efterlade enes erfares falde fattes findes flydyde flyve fnyse forefindes forfryse forgribe forskrækkes forsove forvride forældes fravige fryse færdes føles genfødes glide gnide gribe gælde halvsove hjemfalde hjælpe hundefryse hænge høres hånle indebære indlade kapdrikke kappes kives klukle knivstikke krybe kvæles kæderyge lade le lede ledes lide lyve længes løslade løsnes mindes mistrives mødes nedarves nedlade omgås omtales opleves opslide overfalde overhænge overlade overskride plages ride ryge rygtes samles sidde skambide skamfrysyse ske skide skilles skoggerle skride skridide skrige skyldes skændes skære slide slippe slås smide smugdrikke smugryge smyge småfryse snakkes snige snorksove sove stikke stinke storskrige stortrives stride stryge synes tilfryse trives trænges tækkes tændes udtrykke undres undslippe undvige vantrives vide vige vride væmmes være ynges ynkes æde ældes årelade ;

w_ogeller = og eller ;


!!!!!!!!!!!!!!!!!!!!!!
! Tag Rewrite Rules: !
!!!!!!!!!!!!!!!!!!!!!!

tense > tense : pret past ;
gender > gender_n : m m, f f, nt nt, ut ut, un un, fn fn, mf mf, xpst xpst, xpsts xpsts, xpsto xpsto, xcomp xcomp, xsup xsup, acr acr, GD GD ;
number > number_n : sg sg, sp sp, pl pl, ND ND ;

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Tag Order (Output Patterns): !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

adj:   _.a_adj.a_comp.gender.number.defnes.a_cmp;
n:     _.gender.number.defnes.case.a_cmp;
np:    _.gender.number.defnes.case.a_cmp;
vblex: _.tense.voice.a_cmp;
pr:    _;
adv:   _.a_comp;
ij:    _;
cnjsub: _;
cnjcoo: _;
part:   _;
sent:   _.a_clb;

det_nodef:    _.a_det.gender.number.case;
det_finaldef: _.a_det.gender.number.case.defnes;
det_initdef:  _.defnes.gender.number.case; ! samma<prn><def><un><pl><nom>
det: (if (1.a_det/tl = dem or 1.lemh/tl = "ena")
         1(det_finaldef)
      el-if (1.mainpos/tl = prn and 1.a_det/tl = "")
         1(det_initdef)
      el-if (1.defnes/tl = ind and 1.a_det/tl = "")
         1(det_initdef)
      else
         1(det_nodef)
     );

! Note: attrs not included here are not available to reduction rules
N:     _.gender.number.defnes.case.a_cmp;
A:     _.a_adj.a_comp.gender.number.defnes.case.a_cmp;
NP:    _.gender.number.defnes;
DP:    _.gender.number.defnes;
PP:    _;
VP:    _.tense.number.voice; ! TODO: Put gender/number on VP for pp-samsvar stuff?
ADV:   _;
SENT:  _;
DP2:   _;                       ! issue 80-workaround
S:     _;                       ! issue 80-workaround


!!!!!!!!!!!!!!!!!!!!
! Reduction Rules: !
!!!!!!!!!!!!!!!!!!!!

N ->
     "N2A" %n ?(1.mainpos=adj) { %1(A)[lemcase=$lemcase] }
   | 2: %n.acr      { %1 }      ! don't change lemcase on acronyms
   | %n             { %1[lemcase=$lemcase] }
   | n.*.cmp  %N    { 1[lemcase=$lemcase] %2 }
   | np.*.cmp %N    { 1 %2 }    ! don't change lemcase on propers
   | vblex.*.cmp %N { 1[lemcase=$lemcase] %2 }
   | n.*.cmp-split     [w_ogeller]@cnjcoo %N { 1[lemcase=$lemcase] _ 2 _ %3 }
   | np.*.cmp-split    [w_ogeller]@cnjcoo %N { 1[lemcase=$lemcase] _ 2 _ %3 }
   | vblex.*.cmp-split [w_ogeller]@cnjcoo %N { 1 _ 2 _ %3 } ! don't change lemcase on propers
   ;

A -> "A->adj"       %adj { %1[gender=(if (1.a_comp = pst and 1.gender = GD) un el-if (1.a_comp = sup and 1.gender = GD) fn else $gender),
                              number=(if (1.a_comp = pst and 1.number = ND) pl else $number),
                              a_adj=1.a_adj/tl
                              ] }
   | "A->n+A" n.*.cmp %A { 1 %2 }
   ;

! TODO: Stop <sint> getting copied from sl side if not in tl side!
! <popcorndude> if you specify a side it takes that side or empty, if you don't specify a side it tries tl->ref->sl  [15:41]
! ^nøye<adj><sint><pst><nt><sg><ind>/noga<adj><pst><nt><sg><ind>$
! should not get sint!

NP ->   %N { %1[lemcase=$lemcase] }
    | "ANun" 4: A.*.un %N
       ! Forms with <un> on the dan side of bidix don't inflect for gender
       { 1 _ %2 }
    | "ANnoch" 4: A %N
       ?(2.gender/sl = 2.gender/tl and (1.gender not = GD))
       ! Gender didn't change in bidix
       { 1 _ %2 }
    ! sg.ind takes noun gender if that's nt, ut (and adj isn't första):
    | "ANnt2N" 2: A.*.sg.ind    %N.nt { 1[gender=2.gender] _                              %2 }
    | "ANut2N" 2: A.*.sg.ind    %N.ut { 1[gender=2.gender] _                              %2 }
    | "AN0"    0: A             %N { 1 _                                                  %2 }
    ;

PP -> pr %DP { 1 _ 2 } ;

detOfN: (always
         1(det)[gender=(if (1.number_n = pl or 1.gender/sl = un)
                            un
                        el-if (1.gender_n = un) ! never apply noun <un>-gender to determiner
                            1.gender
                        else
                            1.gender_n
                        ),
                number=1.number_n]
        ) ;
! TODO: when https://github.com/apertium/apertium-recursive/issues/81
! is solved, use that instead of gender_n hack

DP ->
     "en god venn ~> en god venn"
      det %NP
      ?(not (1.number = sg and 2.number = pl)) ! reject if number mismatch (det doesn't modify n)
      { 1(detOfN)[gender=1.gender, gender_n=2.gender, number_n=2.number, lemcase=1.lemcase]
        _
        2[defnes=ind]
      }

    | "vennene mine ~> mina venner"
      %NP det.pos
      ?(not (2.number = pl and 1.number = sg)) ! reject if number mismatch (det doesn't modify n)
      { 2(detOfN)[gender=2.gender, gender_n=1.gender, number_n=1.number, lemcase=1.lemcase]
        _
        1[defnes=ind, lemcase=2.lemcase]
      }

    | %det { %1 }

    | %NP { %1 }
      ;

! TODO: Do any tags need propagating here?
ADV -> "ADV" %adv { %1 }
    | "ADV.nt" %A.*.nt { %1 }
    | det.dem år@N { 1 _ %2 }
    ;

VP ->
      3: %vblex.imp { 1[voice=""] }
    |    %vblex { 1 }

    | "ble teen drukket ~> blev teen drukket"
      2: %[w_bli]@vblex.pret NP [w_no_past_pasv]@vblex.pp
      { %1 _ 2 _ 3 }
    | "ble teen drukket ~> blev teen drukket"
      2: %[w_bli]@vblex.pret NP [w_no_past_pasv]@adj.pp
      { %1 _ 2 _ 3 }

    | "ble landet delt ~> deledes landetV"
      %[w_bli]@vblex NP vblex.pp
      ?(not (3.lemh/tl in w_no_pasv))
      { 3[voice = pasv, tense = 1.tense] _ 2 }
    | "ble landet delt ~> deledes landetA"
      %[w_bli]@vblex NP adj.pp
      ?(not (3.lemh/tl in w_no_pasv))
      { *(vblex)[lemh=3.lemh, voice = pasv, tense = 1.tense] _ 2 }

    | "ble senere delt ~> deledes senereV"
      %[w_bli]@vblex ADV vblex.pp
      ?(not (3.lemh/tl in w_no_pasv))
      { 3[voice = pasv, tense = 1.tense] _ 2 }
    | "ble senere delt ~> deledes senereA"
      %[w_bli]@vblex ADV adj.pp
      ?(not (3.lemh/tl in w_no_pasv))
      { *(vblex)[lemh=3.lemh, voice = pasv, tense = 1.tense] _ 2 }

    | "ble delt ~> deledesV"
      %[w_bli]@vblex vblex.pp
      ?(not (2.lemh/tl in w_no_pasv))
      { 2[voice = pasv, tense = 1.tense] }
    | "ble delt ~> deledesA"
      %[w_bli]@vblex adj.pp
      ?(not (2.lemh/tl in w_no_pasv))
      { *(vblex)[lemh=2.lemh, voice = pasv, tense = 1.tense] }

    ;

! If bidix removed clb, ensure it stays removed:
SENT -> %sent { %1[a_clb = 1.a_clb/tl] } ;



! We need to parse wider contexts in order to work around
! https://github.com/apertium/apertium-recursive/issues/80

! Ideally, we'd only have rules that cover contexts where we need to
! apply a change, but unfortunately there's some deep issue with
! lookahead that means that a verb to the right can block an analysis
! of a verb to the left or something if we try to only do fragmented
! "bottom up" analyses. But if there's a parse covering both verbs,
! the rules will apply.

DP2 ->
      "vennene mine virtuelt" DP A         { %1 _ 2 }
    | "vennene hennes redde"  DP ADV       { %1 _ 2 }
    | "et sekund eller to"    DP cnjcoo DP { %1 _ 2 _ 3 }
    | "gode og fine folk"     A cnjcoo DP  { 1 _ 2 _ %3 }
    ;

S ->
      "S-intrans" DP VP     { %1 _ 2 }
    | "S-trans"   DP VP DP  { %1 _ 2 _ 3 }
    | "S-trans"   DP VP DP2 { %1 _ 2 _ 3 }
    | "S-transA"  DP VP A   { %1 _ 2 _ 3 }
    | "3."        det.qnt sent.clb.remspc   { %1 2 }
    ;
